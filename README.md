
Pager Station

Что это такое?
Простым языком: это программа (веб-приложение, которое выглядит как сайт), с помощью которой вы сможете оживить свой старый пейджер, который уже больше 20-ти лет валяется без дела, и отправлять на него сообщения разными способами.

Для программистов: это обёртка (REST-бэкенд) над замечательной программой rpitx, у которой, помимо всего прочего, есть возможность отправки в эфир сообщений по пейджинговому протоколу POCSAG. В качестве передатчика используется Raspberry Pi, на неё же и устанавливается весь сервис.

Список возможностей:
- отправка приватных сообщений
- периодический сбор из интернета и отправка новостных сообщений (в первой релизной версии - только погода)
- REST-API для отправки сообщений через GET и POST запросы, или подключения своих сервисов
- минимальный веб-интерфейс для отправки сообщений
- веб-панель администратора (так сказать, пейджингового оператора) для настроек



Небольшой FAQ:

Q: Что вообще такое, эти пейджеры?
A: https://ru.wikipedia.org/wiki/Пейджер

Q: Какие пейджеры можно применять?
A: В основном Motorola Advisor, так как по сути только он в наше время поддаётся перепрограммированию, и имеет софт и документацию для этого (ну и ещё у него самый брутальный и узнаваемый вид, конечно же). Работа с другими пейджерами возможна, только при условии что известны их частота и капкод, по этому принципу был успешно опробован двухстрочный пейджер Navigator.

Q: Но ведь у пейджеров коммерческие частоты?
A: Да, и поэтому используется всего лишь Raspberry Pi, с её маломощным передатчиком

Q: Какая дальность передачи у Raspberry Pi?
A: TODO

Q: За сколько доходит сообщение?
A: Смотря сколько их в очереди. Одно передаётся 2-5 сек.

Q: Можно ли установить НЕ на Raspberry Pi?
A: Можно, на любую Linux Debian систему, но зачем. Передатчика там не будет, сообщения будут просто помечаться как отправленные виртуально.

Q: А не слишком ли тяжеловесный проект, ведь можно было проще? И вообще, зачем веб-приложение?
A: Можно было проще. Но по большей части, вся суть данного проекта - это изучение Django+Celery, так что всё построено только на этом

Q: Где аутентификация?
A: Лично мне сейчас это не самое главное, всё равно никуда наружу сервис не торчит. Возможно добавлю позже.

Q: 
A: 







Нам понадобятся
* собственно сам пейджер Motorola Advisor, купленый на Авито во вменяемом состоянии. 
* Raspberry Pi (а также карта памяти и блок питания)
* Переходник USB-TTL
* Несколько проводков с разъёмами Мама
* Скорее всего немного будет нужен паяльник и соответствующие навыки



Подключение и установка на Raspberry Pi

Берём в одну руку Raspberry, а в другую - один проводок с разъёмами. Подключаем его к штырьку GPIO 4 (который седьмой по счёту) и оставляем болтаться - этот проводок у нас будет играть роль плохонькой антенны.
Что-то из теории антенностроения подсказывает, что лучше бы тут использовать четвертьволновый штырь. Для тех кто забыл, нужно скорость света поделить на частоту в герцах (или 300 поделить на мегагерцы) и поделить ещё на 4. 
То есть, при примерной частоте 159 МГц, считаем: 300 / 159 / 4 = 47 сантиметров, желательная длина штыря антенны. И размещать его лучше вертикально.

Далее как обычно, раскатываем на карту памяти образ свежей Raspberry Pi OS (она же Raspbian). Подключаемся по SSH в консоль и первым делом запустим настройки. 
sudo raspi-config

Главное что тут нужно поменять
- сдвинуть доступную GPU Memory на минимум, освободив оперативку
- расширить файловую систему на всю карту памяти (Expand Filesystem)
- по желанию можно разогнать процессор
если потребуется, перезагрузить систему

настраиваем часовой пояс, выбираем свой регион
sudo dpkg-reconfigure tzdata

обновляем систему
sudo apt update
sudo apt dist-upgrade
sudo apt autoremove

по желанию ставим русский язык
sudo apt install language-pack-ru
sudo update-locale LANG=ru_RU.UTF-8

устанавливаем необходимое ПО
sudo apt install git python3-venv python3-dev mariadb-server mariadb-client redis-server memcached nginx

заходим в папку, где мы будем размещать программу (например создаём новую папку "services" в домашней папке, после чего заходим туда) и клонируем себе этот репозиторий
git clone REPONAME
и заходим в папку с ним 
cd REPONAME

установим rpitx
git clone https://github.com/F5OEO/rpitx
cd rpitx
./install.sh
ожидаем окончания сборки, соглашаемся на модификацию config.txt, обязательно перезагружаемся
sudo reboot

снова заходим в папку REPONAME. rpitx уже установлен, нам нужно взять только бинарник и положить его в корень проекта (где req.txt)
cp ./rpitx/pocsag ./pocsag
больше папка rpitx нам не нужна. Удаляем её и навешиваем атрибут на бинарник
sudo rm -r ./rpitx
sudo chmod +x pocsag

Настроим mariadb
sudo mysql_secure_installation
на вопрос о текущем пароле (current root password) просто нажать enter (без пароля)
установить пароль рута (set root password) - говорим no, мы всё равно не будем использовать учётку рута
на все остальные вопросы отвечаем yes
создадим юзера БД, допустим с именем admin и паролем password, с возможностью доступа только из localhost
sudo mariadb
GRANT ALL ON *.* TO 'admin'@'localhost' IDENTIFIED BY 'password' WITH GRANT OPTION;
FLUSH PRIVILEGES;
exit

при необходимости доступа за пределами localhost, учётку нужно называть как
'admin'@'%'
поменяем конфиг
sudo nano /etc/mysql/mariadb.conf.d/50-server.cnf
выставим параметр
bind-address 0.0.0.0
sudo service mariadb restart

в папке с проектом создадим виртуальное окружение:
python3 -m venv venv
source venv/bin/activate
убедимся что мы в окружении - зелёное venv слева от командной строки (проверять в дальнейшем)

скопируем файл системных переменных и дадим атрибут:
cp .env_example .env
chmod 600 .env

Заодно сгенерируем и скопируем себе новый SECRET_KEY
python -c 'from django.core.management.utils import get_random_secret_key; print(get_random_secret_key())'
отредактируем файл
nano .env
обращаем внимание, что до и после знака равно не должно быть пробелов

SECRET_KEY - сюда вставляем только что сгенерированый секретный ключ
DEBUG - для вывода отладочных сообщений - True. В рабочей версии и для лучшей безопасности лучше оставить False
DB_NAME, DB_HOST, DB_USER, DB_PASS - параметры доступа к БД
TOKEN_OWM - токен OpenWeatherMap (TODO как получить)
WEATHER_CITY - город для прогноза погоды (TODO формат)

в настройках часовой пояс и язык

cp celery.example.conf celery.conf
поменять параметр CELERY_BIN
/home/pi/services/pagerstation/venv/bin/celery

установим зависимости
pip install -r requirements.txt

проведём миграции БД и соберём статику
python manage.py migrate
python manage.py collectstatic

также необходимо создать суперюзера
python manage.py createsuperuser

Можно проверить как работает сервер Django
python manage.py runserver 0:80
И планировщик Celery
celery -A pagerstation worker -l info -B


Далее условимся что папка с проектом находится по пути /home/pi/services/pagerstation
Если она расположена в другом месте, меняем этот путь во всех нижеприведённых конфигах


Создадим конфиг nginx, удалив при этом стандартный
sudo rm /etc/nginx/sites-enabled/default
sudo nano /etc/nginx/sites-available/pagerstation

Вставим текст
```
server {
    listen 80;
    server_name ;

    location = /favicon.ico { access_log off; log_not_found off; }
    location /static/ {
    root /home/pi/services/pagerstation;
    }

    location / {
    include proxy_params;
    proxy_pass http://unix:/home/pi/services/pagerstation/pagerstation.sock;
    }
}
```
Создадим ярлык и проверим конфигурацию
sudo ln -s /etc/nginx/sites-available/pagerstation /etc/nginx/sites-enabled
sudo nginx -t
sudo systemctl restart nginx

Создадим конфиг для gunicorn
sudo nano /etc/systemd/system/pagerstation_gunicorn.service

[Unit]
Description=gunicorn daemon
After=network.target
PartOf=pagerstation.service

[Service]
User=root
Group=www-data
WorkingDirectory=/home/pi/services/pagerstation
ExecStart=/home/pi/services/pagerstation/venv/bin/gunicorn --access-logfile - --workers 2 --bind unix:/home/pi/services/pagerstation/pagerstation.sock pagerstation.wsgi:application

[Install]
WantedBy=multi-user.target

Конфиг для воркера celery
sudo nano /etc/systemd/system/pagerstation_celery_worker.service

[Unit]
Description= PagerStation Celery Worker Service
After=network.target
PartOf=pagerstation.service

[Service]
Type=forking
User=pi
Group=pi
EnvironmentFile=/home/pi/services/pagerstation/celery.conf
WorkingDirectory=/home/pi/services/pagerstation
RuntimeDirectory=celery
ExecStart=/bin/sh -c '${CELERY_BIN} -A $CELERY_APP multi start $CELERYD_NODES \
    --pidfile=${CELERYD_PID_FILE} --logfile=${CELERYD_LOG_FILE} \
    --loglevel="${CELERYD_LOG_LEVEL}" $CELERYD_OPTS'
ExecStop=/bin/sh -c '${CELERY_BIN} multi stopwait $CELERYD_NODES \
    --pidfile=${CELERYD_PID_FILE} --logfile=${CELERYD_LOG_FILE} \
    --loglevel="${CELERYD_LOG_LEVEL}"'
ExecReload=/bin/sh -c '${CELERY_BIN} -A $CELERY_APP multi restart $CELERYD_NODES \
    --pidfile=${CELERYD_PID_FILE} --logfile=${CELERYD_LOG_FILE} \
    --loglevel="${CELERYD_LOG_LEVEL}" $CELERYD_OPTS'
Restart=always

[Install]
WantedBy=multi-user.target

Конфиг для планировщика celery
sudo nano /etc/systemd/system/pagerstation_celery_beat.service
```bash
[Unit]
Description=PagerStation Celery Beat Service
After=network.target
PartOf=pagerstation.service

[Service]
Type=simple
User=pi
Group=pi
EnvironmentFile=/home/pi/services/pagerstation/celery.conf
WorkingDirectory=/home/pi/services/pagerstation
RuntimeDirectory=celery
ExecStart=/bin/sh -c '${CELERY_BIN} -A ${CELERY_APP} beat  \
    --pidfile=${CELERYBEAT_PID_FILE} \
    --logfile=${CELERYBEAT_LOG_FILE} --loglevel=${CELERYD_LOG_LEVEL}'
Restart=always

[Install]
WantedBy=multi-user.target
```
И один конфиг, чтобы править всеми

```bash
sudo nano /etc/systemd/system/pagerstation.service
```
Вставить текст:
```bash
[Unit]
Description=PagerStation Group Service
Wants=pagerstation_gunicorn.service
Wants=pagerstation_celery_worker.service
Wants=pagerstation_celery_beat.service

[Service]
Type=oneshot
ExecStart=/bin/echo "Starting PagerStation instances"
RemainAfterExit=yes
StandardOutput=journal

[Install]
WantedBy=multi-user.target
```
Папки для логов
```bash
sudo mkdir /var/log/celery
sudo chown pi:pi /var/log/celery
sudo chmod 0755 /var/log/celery
```

Обновим и поставим в автозапуск стартовые скрипты
sudo systemctl daemon-reload
sudo systemctl enable pagerstation

Теперь для ручного запуска можно вводить команду
sudo service pagerstation start

Настройка завершена, для полной надёжности можно перезапустить систему, сервис стартует автоматически.





Перепрограммирование пейджера

Желающие более плотнее ознакомиться с принципами работы пейджинговой связи, могут сделать это по ссылкам в конце этого текста. Тут я приведу только краткую выжимку - для начала ознакомимся с применяемыми терминами:

- абонентский номер. Чаще всего - четырёхзначное число, присвоенное абоненту, чисто для удобства использования (его раньше называли оператору в телефоне, перед тем как надиктовать сообщение)
- капкод (CAPCODE). Уникальный номер (максимум семизначный) вшитый оператором в пейджер во время программирования. Именно на него передатчик шлёт сообщение, и именно он однозначно определяет, какое сообщение пейджер будет считать своим - принцип работы пейджинговой связи такой, что пейджер постоянно слушает эфир, и как только ловит принадлежащий ему капкод - то принимает и сохраняет следующее далее сообщение. Если это чужой капкод - то уходит в спячку до следующей передачи. Капкод и абонентский номер - это разные номера, по той самой причине, что зная чужой капкод, можно запрограммировать свой пейджер на него и принимать чужие сообщения. В отличие от приватных, новостные и групповые капкоды во все пейджеры зашиваются одинаковые, чтобы одну посылку могли принять сразу все.
- биты источника. Число от 0 до 3, задаёт, условно говоря, подкатегорию капкода. Используется это по разному. Например, по части приватных сообщений, если у нас очень много абонентов (больше 9999999, и такое видимо бывало), то мы можем присвоить нескольким абонентам один капкод, но с разными битами. Условно говоря, капкод 987654 и источник 0 - это абонентский номер 1111, а тот же капкод 987654 и источник 1 - это уже абонент 1112, принадлежащий другому человеку. По части новостных сообщений - используется для сортировки пейджером, так как новостные сообщения хранятся в памяти только последние, число источника указывает на ячейку, в которой будет свежая информация о конкретной новости (погода, курсы валют, итд)
- кодировка текста. Бывает латинская, русская, и смешанная (у такой только заглавные буквы)
- частота. В мегагерцах, на которой пейджер принимает сообщения. По сути, если задать частоту в пределах fm-диапазона, то можно услышать что посылки с сообщениями - это характерный звук.


Для дальнейшей работы нам понадобится компьютер, на который установлены:
- DosBox (ибо софт древний, написан под ДОС)
- архив с программой
- возможно драйвера на TTL переходник

Для начала выясним частоту пейджера, для этого потребуется его разобрать, благо это делается вообще без винтов.
Берём в руки пейджер, видим на нижней грани защёлку. Нам нужно с правой стороны её отогнуть ногтем от корпуса, а с левой толкать в правую сторону. Защёлка выйдет, после чего корпус распадётся на две половинки. 
Посередине мы видим плату, просто вставленную в гнездо. Это и есть передатчик, нам нужно его отсоединить, и заглянуть вот сюда, под синюю обёртку.

Нам нужно глянуть, что написано на этом кварце - некое число вроде 47.041. Это частота кварца, и чтобы нам получить из неё частоту пейджера, нужно её умножить на 3 и прибавить 17.9.
То есть, 47.041 * 3 + 17.9 = 159.023 МГц - частота нашего пейджера. Эта формула работает только для Motorola Advisor, с другими - только надеятся на удачу. А теперь смотрим на наклейки на задней крышке пейджера. Если расчитаная частота совпала с написанной, то нам крупно повезло, можно было даже не разбирать. Однако чаще всего надпись на наклейке не совпадает - местные операторы в большинстве случаев скручивали частоты под свои передатчики.

Настало время самой сложной части - перепрограммирования пейджера.

Снова берём пейджер в руки, и видим на его левом торце три отверстия, за которыми виднеются контакты. Это COM-порт, и через него мы будем подключать его к компьютеру. Контакты именуются, если слева направо и экраном вверх - Rx, Tx, GND. Соответственно, контакт для приёма данных, для передачи, и общий.
Затем берём в руки наш TTL-переходник, и видим на нём, как ни странно, те же самые контакты. Так вот, нам нужно нацепить три провода с разъёмами на одноимённые контакты переходника, а с другого конца обрезаем разъёмы, зачищаем, и подключаем их в отверстия пейджера. Внимание - подключение идёт попарно! То есть, Rx переходника в Tx пейджера, и Tx переходника в Rx пейджера. Общий провод, понятное дело, одинаковый. Если на переходнике есть переключатель 3.3/5v, то желательно выставить 3.3, хотя в принципе нормально работает и на 5v.
Как закрепить провода в отверстиях - тут уж как фантазии хватит. Главное чтобы при самой прошивке контакт не нарушался, пейджеры этого не любят. Лично я делал так - приподнимал из корпуса основную плату с экраном, засовывал в отверстия корпуса проводки, затем опускал на место плату и она прижимала собой провода к контактам. Для надёжности можно прилепить их ещё изолентой к корпусу, чтобы случайно не вырвать. Главное чтоб контакты между собой внутри не замкнулись! 
Вставляем в пейджер батарейку (можно его так и оставить полуразобранным, хоть с отсоединённым передатчиком), и подключаем переходник к компу. Идём в диспетчер устройств и запоминаем, на какой COM-порт у нас установился переходник. Если новых портов (кроме COM1-2) не появилось, то нужно установить драйвера на переходник.

Архив с ПО для прошивки разархивируем в отдельную папку, нечто вроде D:\DOS\AdvisorTools
Проверяем чтобы внутри папки AdvisorTools лежал файл ADVCNFGF.ILE - он определяет что ПО установлено нормально.

Открываем конфиг DosBox (в Пуске пункт меню DosBox Options). Открывается текстовый файл настроек.

В самый низ вставляем 
mount C D:\DOS\AdvisorTools


И чуть выше ищем пункт, что-то вроде serial1=dummy. Меняем его на 
serial1=directserial realport:com4
соответственно, вместо com4 указываем номер вашего переходника.
Запускаем DosBox, переходим на диск C в папку moto, и запускаем ADVISOR.EXE

Первым делом жмём F9, переходим в настройки. Проверяем, чтобы пути соответствовали реальным (чтобы папка после C:\ действительно называлалсь "moto"), и чтобы был выставлен порт COM1. Если что, меняем, сохраняем, перезапускаем программу.
Первым делом жмём F3 - считываем данные из пейджера. Следим за переходником, во время передачи данных на нём быстро перемигиваются лампочки. Если это не так, или они не горят, то нужно проверить правильность всего вышеперечисленного, а также прочность контактов из проводков.
Здесь в большинстве случаев нас будет ждать облом - пейджеры почти всегда запаролены оператором от вмешательства. Ну типа, чтоб рукастые абоненты не своевольничали, не добавляли себе платных новостных каналов, или чтоб не уходили к другим операторам. ВНИМАНИЕ - не стоит здесь пытаться подобрать пароль - пейджер выдержит несколько попыток, после чего заблокируется намертво (на нём будет гореть только надпись "ПЕЙДЖЕР ЗАБЛОКИРОВАН" или типа того) и его больше нельзя будет использовать даже как будильник! 
Однако ж, мы можем сбросить пароль (а также разблокировать пейджер, если всё же набедокурили в предыдущем абзаце).

Для этого, отключаем пейджер от компа, разбираем его, и смотрим внимательно на основную плату

Это микросхема памяти, нас интересует одна отмеченая ножка - четвёртая слева

Расчехляем паяльник и АККУРАТНО (не спаяв соседние ножки) припаиваем тонкий проводок к этому контакту. Второй его конец зажимаем на минусовой контакт батарейки (вставляем её). Этим самым мы нарушили связь пейджера с его собственной прошивкой, и на экране скорее всего будет отображаться всякий мусор.
Снова подключаем пейджер к компу и запускаем DosBox. Переходим на диск C, в папку moto\pass и запускаем RSS.EXE
Нажимаем пробел - по экрану побегут цифры и через несколько секунд замрут. Следим за процессом, если цифры долгое время циклически повторяются, и каждый раз пейджер начинает истерично пищать - нужно остановить и проверить качество припаянного проводка, так как при плохом контакте пейджер воспринимает взлом как попытки перебора пароля и блокируется как описано выше. 
Если цифры замерли и больше не реагируют на пробел, закрываем программу, отключаем батарейку и провод от минусового контакта, и пробуем всё заново - вставляем батарейку, подключаемся через программу ADVISOR.EXE и пробуем считать настройки. Разблокировка может пройти не с первого раза, поэтому провод от микросхемы не отпаиваем и пробуем ещё раз. Если настройки успешно считались, то провод можно отпаять (или оторвать) и забыть об этом - пароль сброшен. Точнее, сбрасывается не пароль, а флаг о том что нужно его запрашивать.

После всего этого, мы можем видеть (и менять) настройки, загруженные из пейджера. Они расположены на нескольких страницах, переключение между ними идёт по нажатию PageUp/PageDown. Все пункты настроек описывать не буду, только самые основные. На каждом пункте можно нажать F1 и прочитать, что он означает.
На первой странице:
- Serial #: серийный номер пейджера. Поменять нельзя, но можно сохранить куда-нибудь себе для аутентичности, в случае повреждения прошивки пейджер спросит новый серийный номер.
- Coding Format - обязательно POCSAG 1200. Меньше - медленнее, больше - нестабильнее.

Далее мы видим то, над чем придётся поднапрячь мозги - капкоды и их настройки. Более подробно вся эта тема раскрывается по ссылке в конце, в разделе использованных источников. В принципе, если неохота заморачиваться изменением капкодов, можно просто тут запомнить себе, какие капкоды зашил в пейджер последний оператор.
У пейджера может быть 4 капкода (соответственно, Code A B C D), каждый из которых ещё подразделяется четырьмя "битами-источниками".
Code Type - тип данного капкода. Individual - приватный, Group - групповой, Mail Drop - новостной
Цифры 1234 посередине - это обозначения битов-источников (вообще они идут с нуля - 0123)
Functions T,A,N,X - как будет воспринято сообщение, принятое на данный капкод+бит.
A - как обычное текстовое
N - "числовое" (уже не используется, это про старую кодировку, передающую только цифры)
T - тональное (сообщение без текста, пейджер просто запищит)
X - сообщение будет отброшено (используется, если мы раздаём один капкод нескольким абонентам, и делаем различие только в битах)
Priority Y,N - сообщение с битом, отмеченным тут как Y будет принято со звуковым сигналом, независимо от настроек беззвучности пейджера

А теперь, главное внимание, особо мозговыносящая вещь!
Капкоды должны вручную задаваться не абы как, а должны правильно располагаться попарно в одинаковых фреймах! То есть, Code A и Code B должны располагаться в одном фрейме, Code C и Code D - во втором. Причём второй должен быть больше первого. Программа конечно предупредит, если что-то не так, но всё же знать надо. Нарушение этого приведёт к сокращению вдвое времени работы от одной батарейки - пейджеру придётся чаще просыпаться для проверки посылок.
Как узнать номер фрейма? Тут нам поможет прилагающийся к проекту скрипт whatcapcode.py
Вызываем его из командной строки с указанием предполагаемого капкода
python whatcapcode.py 503125
В ответ он выдаст номер фрейма - 5. Всего фреймов 8 (от 0 до 7). При увеличении капкода на 1, фрейм тоже увеличивается на 1, пока не дойдёт до 7, дальше отсчёт снова пойдёт с нуля. То есть к примеру, капкоды 525349, 37 - относятся к 5-му фрейму, и их можно использовать в паре. По тому же принципу делаем вторую пару капкодов, к примеру 191 и 199 - фрейм у них будет 7-ой, и он больше чем 5ый.
Ну и ещё - не рекомендуется использовать капкоды от 0 до 8

Если всё вышеперечисленное непонятно (я тоже долго не мог понять), то просто делаем как я:

Капкод Code A задаём 0525349, функции выставляем ATXX, приоритет NNNN, Code Type - Individual
Капкод Code B задаём 0000037, функции выставляем AAXX, приоритет YNNN, Code Type - Group
Капкод Code C задаём 0000191, функции выставляем AAAA, приоритет NNNN, Code Type - Mail Drop
Капкод Code D задаём 0000199, функции выставляем AAAA, приоритет NNNN, Code Type - Mail Drop

Что мы имеем из всего этого?
- Сообщение на капкод 525349 + биты 0 - принимается как приватное в обычном текстовом виде
- Сообщение на капкод 525349 + биты 1 - принимается как приватное в тоновом виде (просто запищит)
- Сообщение на капкод 37 + биты 0 - принимается как групповое с громким оповещением, независимо от режима беззвучности
- Сообщение на капкод 37 + биты 1 - принимается как групповое
- Сообщение на капкод 191 + биты 0 - принимается как новостное и будет хранится в отдельной ячейке во второй строке
- TODO расписать остальные


Закончив наконец с капкодами, переходим на следующую страницу настроек (PageDown). На остальных страницах настраиваем всё по своему вкусу. Если что - F1 справка по пункту. 
На четвёртой странице можно задать собственные служебные строки (название оператора, или уведомления вроде "УДАЛИТЬ?" и "ЗАМЕНИТЕ БАТ.")
Наконец на самой последней странице, проверив что наш пейджер до сих пор включён и крепко подсоединён проводами, можно нажать F4 и запрограммировать изменения в пейджер. Если здесь будет нарушен контакт с проводами - прошивка слетит, появится мусор на экране, придётся всё настраивать с нуля. В случае успешной прошивки пейджер перезагрузится, запищит, и на этом месте можно его отсоединять от компьютера, собирать обратно и переходить (запомнив конечно, что за номера мы в него внесли) к настройке собственно программы.


Первоначальная настройка

Заходим на IP-адрес нашей Raspberry Pi, в раздел администрирования
http://192.168.1.129/admin/
Вводим логин/пароль, который создавали ранее командой createsuperuser

Отправлять сообщения напрямую (по частоте, капкоду, итд) можно без настроек, но для того чтобы отправлять по абонентскому номеру или получать новостную рассылку, их нужно произвести.

Для начала в левой панели переходим в Transmitters, создаём там новый, условно говоря "передатчик" - нужно будет ввести имя (например "Моторола") и частоту (в герцах, например 158125000). Если у нас несколько пейджеров, работающих на разных частотах, для каждой частоты создаём свой "передатчик".

Затем переходим в раздел Pagers. Здесь мы собственно будем задавать параметры конкретного пейджера
- его абонентский номер (кто не читал, в разделе выше объясняется разница между абонентским номером и капкодом)
- приватный капкод (известный, или заданый при перепрограммировании пейджера)
- биты источника (скорее всего просто 0)
- кодировка текста. Соответственно, lat - если пейджер поддерживает только английские буквы, cyr - только кириллицу, linguist - если и то и другое. Если неизвестно, определяется опытным путём
- трансмиттер. Выбираем среди тех что мы создали абзацом ранее

Затем идём в раздел Clients. Тут мы зададим образно говоря, абонента нашей супер пейджинговой станции
- ФИО
- Дата рождения (чтобы в будущем рассылать поздравления)
- в выпадающем списке выделяем абонентские номера, которые будут ему принадлежать

Идём в раздел NewsChannels. Здесь мы зададим параметры новостных рассылок
- категория (погода, новости, итд)
- новостной капкод (тот что указали при перепрограммировании)
- биты источника (в каком порядке пейджер будет сортировать сообщения. Имеем в виду, что новостное сообщение в пейджерах хранится только самое последнее, так что тут мы задаём условно говоря, ячейку памяти, где данная категория новостей будет гнездиться)
- кодировка текста
- трансмиттер
Суть этого раздела в том, чтобы программа отправляла одинаковое новостное сообщение (с одинаковой категорией) на разные трансмиттеры или новостные капкоды. Но если пейджер у нас ровно один, это не имеет значения.

Вот и всё, настройка завершена, на пейджер будет приходить новостная рассылка, а мы теперь сможем отправлять сообщения на абонентский номер



Примеры использования (отправка приватных сообщений на абонентский номер)
1. С помощью веб-интерфейса DRF

заходим в браузере на IP-адрес Raspberry Pi, в раздел API - http://192.168.1.123/api, там мы видим доступные нам возможности, в виде ссылок. Выбираем отправку приватных сообщений - http://192.168.1.129/api/privatemessages/

Открывается минимальный интерфейс, достаточный для отправки. Мы просто вводим в поля абонентский номер и текст сообщения, после чего кнопкой отправляем его. 

2. С помощью POST запроса к REST-API (для примера - из консоли)
curl -X POST http://192.168.1.123/api/privatemessages/ -H 'Content-Type: application/json' -d '{"subscriber_number":"1234","message":"Привет всем!"}'
(соответственно, подставить свои IP-адрес, абонентский номер, текст сообщения)


Использованные источники

Статьи и видео
Hot Pixel https://www.youtube.com/watch?v=ukmvlHdsdfc
SinuX https://mysku.ru/blog/diy/88396.html https://mysku.ru/blog/diy/88811.html 
https://cxem.net/telefon/2-28.php

Сторонние программы и сервисы
https://github.com/F5OEO/rpitx 
https://pyowm.readthedocs.io/en/latest/v3/code-recipes.html#weather_forecasts

